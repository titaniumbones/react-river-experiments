{"version":3,"sources":["rivers.js","components/waterchart.js","libraries/chartist-segmented-line.js","DataParsers.js","serviceWorker.js","components/markdownFromUrl.js","components/riverTabPanel.js","components/watertabs.js","components/sessionInfo.js","components/journalForm.js","components/journal.js","index.js"],"names":["Rivers","name","gaugeType","gaugeID","slug","points","putin","takeout","minHeight","levels","Segment","global","Chartist","waterchartDefaultOptions","scaleMinSpace","showArea","axisX","type","FixedScaleAxis","divisor","labelInterpolationFnc","value","index","moment","format","axisY","plugins","ChartistTooltip","tooltipFnc","meta","p","deserialize","units","date","data","magnitude","toFixed","dateSpan","magSpan","quality","anchorToPoint","appendToBody","height","width","Waterchart","props","updateData","console","log","spotDef","spotslug","processGauge","then","dispatch","id","valueOf","payload","gaugeData","componentDidMount","seriesdata","checkUpdates","keepUpdating","setInterval","componentDidUpdate","chartRef","current","options","chart","clientWidth","r","getSpot","React","createRef","clearInterval","this","series","className","forceHidden","ref","needsUpdate","Component","defaultProps","connect","state","ownProps","chartId","chartInfo","charts","globalRoot","defaultOptions","offset","position","labelOffset","x","y","showLabel","showGrid","noop","undefined","onlyInteger","showLine","showPoint","areaBase","lineSmooth","showGridBackground","low","high","chartPadding","top","right","bottom","left","fullWidth","reverseData","classNames","label","labelGroup","line","point","area","grid","gridGroup","gridBackground","vertical","horizontal","start","end","segmentClassPrefix","metaRangeProperty","metaRangeValue","SegmentedLine","Base","extend","constructor","query","responsiveOptions","super","call","createChart","normalizeData","svg","createSvg","container","elem","addClass","seriesGroup","chartRect","createChartRect","padding","StepAxis","Axis","normalized","ticks","labels","stretch","AutoScaleAxis","isNumeric","createGridAndLabels","supportsForeignObject","eventEmitter","createGridBackground","raw","forEach","seriesIndex","seriesElement","attr","serialize","alphaNumerate","join","testCase","segments","metaField","segName","push","collectSegments","segment","segmentIndex","segmentElement","segmentPathCoordinates","segmentPathData","valueIndex","x1","projectValue","y1","getMetaData","bind","seriesOptions","getSeriesOption","segmentPath","Interpolation","monotoneCubic","none","pathElements","length","pathElement","x2","y2","filter","direction","emit","group","element","d","stringify","values","path","clone","seriesMeta","range","Math","max","min","areaBaseProjected","splitByCommand","pathSegment","map","solidPathSegments","firstElement","lastElement","remove","move","areaPath","bounds","gaugeDict","cvc","processWiskiData","grca","wateroffice","spot","latest","a","async","getWOJSON","rawData","item","Number","testGood","Date","catch","err","level","spotMeta","some","last","baseURL","subtract","url","fetch","res","headers","get","json","error","stationData","needCors","Origin","params","provisional","mapper","Boolean","window","location","hostname","match","MarkdownFromUrl","errText","text","substring","setState","content","Point","l","href","PointList","pEntries","Object","entries","key","RiverTabPanel","river","WaterTabs","rivers","contentMap","tabMap","tabList","tabPanelArray","defaultIndex","defaultFocus","SessionInfo","el","containerRef","s","JournalForm","handleSubmit","entry","submit","handleChange","event","target","checked","onSubmit","info","preventDefault","uuid","onChange","journal","Journal","JournalAllEntries","dataObj","showForm","JournalRow","showInfo","infoShown","toggleForm","onClick","persistConfig","storage","initialState","sessions","persistedReducer","persistReducer","action","newState","store","createStore","__REDUX_DEVTOOLS_EXTENSION__","persistor","persistStore","ReactDOM","render","loading","to","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.6d604538.chunk.js","sourcesContent":["const streetsville = {\n  \"name\": \"Credit River at Streetsville\",\n  \"slug\": \"lowercredit\",\n  \"gaugeType\": \"wateroffice\",\n  \"gaugeID\": \"02HB029\",\n  \"units\": \"cms\",\n  \"lat\":123.456,\n  \"long\": -456.789,\n  \"levels\": [[0,4.6,\"bad\"], [4.6,8,\"shoulder\"], [8,50,\"good\"],[50,100,\"shoulder\"]],\n  \"qualityPeaks\": [ [0,\"bad\"], [85, \"good\"], [170, \"bad\"], [290, \"bad\"] ],\n  \"minHeight\": 4.6\n},\n      // irvine =   {\n      //   \"name\": \"Irvine\",\n      //   \"gaugeType\": \"wateroffice\",\n      //   \"gaugeID\": \"02GA005\",\n      //   \"slug\": \"irvine\",\n      //   \"units\": \"cms\",\n      //   \"points\":{ \n      //     \"putin\": [43.702321,-80.445578] ,\n      //     \"takeout\": [43.662701, -80.453265] \n      //   },\n      //   \"levels\": [[0,4.6,\"bad\"], [4.6,8,\"shoulder\"], [8,50,\"good\"],[50,100,\"shoulder\"]],\n      //   \"qualityPeaks\": [ [0,\"bad\"], [85, \"good\"], [170, \"bad\"], [290, \"bad\"] ],\n      //   \"minHeight\": 4.6\n      // },\n      irvine =   {\n        \"name\": \"Irvine\",\n        \"gaugeType\": \"grca\",\n        // \"gaugeID\": \"Irvine R. Salem\",\n        gaugeID: 8773042,\n        \"slug\": \"irvine\",\n        \"units\": \"cms\",\n        \"points\":{ \n          \"putin\": [43.702321,-80.445578] ,\n          \"takeout\": [43.662701, -80.453265] \n        },\n        \"levels\": [[0,4.6,\"bad\"], [4.6,8,\"shoulder\"], [8,50,\"good\"],[50,100,\"shoulder\"]],\n        \"qualityPeaks\": [ [0,\"bad\"], [85, \"good\"], [170, \"bad\"], [290, \"bad\"] ],\n        \"minHeight\": 4.6\n      },\n\n      elora = {\n        name: \"Elora Gorge at Shand Dam\",\n        gaugeType: \"grca\",\n        gaugeID: 7405042,\n        //gaugeID: 11189042,\n        //gaugeID: 14389,\n        //gaugeID: 'Shand Dam Discharge',\n        \"units\": \"cms\",\n        slug: \"grand\",\n        points: {\n          putin: [43.4379897,-80.2842689],\n          takeout:[43.662701, -80.453265]\n        },\n        minHeight: 5,\n        levels: [[0,4.6,\"bad\"], [4.6,8,\"shoulder\"], [8,50,\"good\"],[50,100,\"shoulder\"]],\n      },\n      upperCredit = {\n        name: \"Upper Credit River at Belfountain\",\n        gaugeType: \"cvc\",\n        gaugeID: '14522010',\n        \"units\": \"cms\",\n        slug: \"uppercredit\",\n        points: {},\n        minHeight: 0.75,\n        levels: [[0,0.75,\"bad\"], [0.75, 0.78,\"shoulder\"], [0.78, 1.1,\"good\"],[1.1,100,\"shoulder\"]],\n      }\n\n\nconst Rivers =[elora, streetsville, upperCredit, irvine];\n\nexport {streetsville as lowercredit}\nexport default Rivers;\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport ChartistGraph from 'react-chartist';\nimport moment from 'moment'\n// import {Resizable, ResizableBox} from 'react-resizable'\n// const Chartist=require( '../libraries/chartist-with-segments.js')\nimport Segment from '../libraries/chartist-segmented-line.js'\nimport Chartist from 'chartist';\nimport ChartistTooltip from 'chartist-plugin-tooltips-updated';\nimport '../../node_modules/chartist-plugin-tooltips-updated/dist/chartist-plugin-tooltip.css'\nimport { connect } from 'react-redux';\nimport Rivers from  '../rivers.js';\nimport {processGauge} from '../DataParsers.js'\n\n\n// Add this function:\n// right now this is mostly irrelevant.\n// we don't set data here,\n// which seems a little silly.  component should probably\n// figureo ut its own data requirements\n// ratherthan ask another component to do it. \nfunction mapStateToProps(state, ownProps) {\n  const chartId = `${ownProps.spotslug}_${ownProps.date? moment(ownProps.date).valueOf() : 'latest'}`, \n        chartInfo = state.charts[chartId],\n        seriesdata = chartInfo && chartInfo.gaugeData,\n        height = chartInfo && chartInfo.height,\n        width = chartInfo && chartInfo.width\n  console.log('CHARTMAPPER', chartId, state.charts[chartId], ownProps)\n  return {\n    height: height,\n    width: width,\n    seriesdata: seriesdata\n  };\n}\n\n// initialize the segment chart type\nSegment(this || global, Chartist)\n\n\n\nfunction getSpot (slug) {\n  let value;\n  console.log(\"GETSPOT\", slug)\n  for (const r of Rivers) {\n    console.log('GETSPOT', r.slug, slug);\n    if (r.slug === slug ) {value = r;}\n  }\n  return value;\n}\n\n\nfunction generateTooltip (meta, value) {\n  // console.log(meta);\n  // console.log('THIS IS THIS', value);\n  const p = Chartist.deserialize(meta),\n        units = p.units;\n  // console.log(p, units, value);\n  //console.log (p.quality, p.direction,(p.wvd ? \"wave\" : \"wind\"), (p.wvd || p.wdir));\n  const date = moment(p.data[0]),\n        magnitude =  p.data[1].toFixed(2);\n  let dateSpan = `<span class=\"chartist-tooltip-value\">${date.format('MM-D HH:mm')}</span>`,\n      magSpan = `<span>${magnitude} ${units}; </span>`,\n      output = `<div class=\"${p.quality} container\">${magSpan}<br>${dateSpan}</div>`\n  return output\n}\n\nconst waterchartDefaultOptions =  {\n  scaleMinSpace: 200,\n  showArea: true,\n  axisX: {\n    type: Chartist.FixedScaleAxis,\n    divisor: 15,\n    labelInterpolationFnc: function(value, index) {\n      return moment(value).format('MM-DD [\\n] HH:mm')\n    }\n  },\n  axisY: {scaleMinSpace: 200},\n  plugins: [\n    ChartistTooltip({\n      tooltipFnc: generateTooltip, \n      anchorToPoint: false,\n      appendToBody: false,\n      \n      //metaIsHTML: true\n    })\n  ],\n  height: 350,\n  width: 700,\n};\n\n\nexport class Waterchart extends Component {\n  constructor(props) {\n    super(props)\n    console.log(\"UPDATECHART IN CONSTRUCTOR\", this.spotDef, this.props.date, this.props.spotslug, this.props)\n    \n    this.spotDef = getSpot(this.props.spotslug)\n    this.chartRef = React.createRef();\n    this.type =  'SegmentedLine';\n    this.options = {...waterchartDefaultOptions,\n                    height: this.props.height || waterchartDefaultOptions.height,\n                    width: this.props.width || waterchartDefaultOptions.width}\n\n  }\n\n  updateData = () => {\n    console.log(\"UPDATECHART\", this.spotDef, this.props.date, this.props.spotslug, this.props)\n    this.spotDef && processGauge(this.spotDef, this.props.date)\n      .then (data =>{\n        console.log('UPDATECHARTDATA', data)\n        this.props.dispatch({type: 'UPDATE_CHART',\n                             id: `${this.props.spotslug}_${this.props.date? moment(this.props.date).valueOf() : 'latest'}`,\n                             payload: {gaugeData: data},\n                            });\n        // this.setState({rendered: true, gaugeData: data})\n      })\n  }\n\n  \n  componentDidMount = () => {\n    console.log('DIDMOUNT', this.props.seriesdata)\n    if (!this.props.seriesdata) {\n      this.updateData()\n    }\n    \n    if (this.props.checkUpdates) {\n      this.keepUpdating = setInterval(this.updateData(), 120000) }\n    // this.setState({data:{\n    //   series: [\n    //     {name: 'Gauge date in CMS',\n    //      data: this.props.seriesdata}\n    //   ]}})\n  }\n\n  componentDidUpdate = () => {\n    console.log('DIDUPDATE')\n    if (this.chartRef.current &&\n        this.options.width !== this.chartRef.current.chart.clientWidth) {\n      // update width and height somewhere\n    }\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.keepUpdating);\n  }\n  \n  render() {\n    const series = [\n      {name: 'Gauge date in CMS',\n       data: this.props.seriesdata},\n      {\n        className: this.props.forceHidden ? 'hidden' : 'active',\n        data: []\n      }\n    ]\n    // console.log('FORCEHIDDEN', this.props.forcHidden)\n    // console.log(\"SERIESDATA\", this.props.seriesdata, this.state.data)\n    // console.log('CHARTREF', this.chartRef.current)\n    // console.log('CHARTREFCLI', this.chartRef)\n    // if (this.chartRef.current) {\n    //   // this.state.options.width= this.chartRef.current.chart.clientWidth\n    //   // this.state.options.height= this.chartRef.current.chart.clientHeight\n    //   console.log('CHARTREF2', this.chartRef.current.chart.__chartist__.update)\n    //   //this.chartRef.current.chart.__chartist__.update(series, this.state.options)\n    // }\n    return (\n      <>\n      { !this.props.forceHidden &&  this.props.seriesdata ?\n       <ChartistGraph ref={this.chartRef} data={{series: series}}\n                      options={this.options} needsUpdate={this.props.forceHidden}\n                      type={this.type} className=\"waterchart\" /> :\n       <h3>No Data Yet</h3>\n      }\n      </>\n    )\n  }\n}\n\nWaterchart.propTypes = {\n  spotslug: PropTypes.string.isRequired,\n  seriesdata: PropTypes.array,\n  forceHidden: PropTypes.bool,\n  //TODO: appropriate validator for date \n  // date: PropTypes.number,\n  height: PropTypes.number,\n  width: PropTypes.number,\n  checkUpdates: PropTypes.bool\n}\n\nWaterchart.defaultProps = {\n  // date: moment.valueOf(),\n  height: 350,\n  width: 700,\n  checkUpdates: false\n}\n\nexport default connect(mapStateToProps)(Waterchart)\n","/**\n * The Chartist line chart can be used to draw Line or Scatter charts. If used in the browser you can access the global `Chartist` namespace where you find the `Line` function as a main entry point.\n *\n * For examples on how to use the line chart please check the examples of the `Chartist.Line` method.\n * CHARTIST MUST BE IMPORTED IN PARENT FILE FIRST, and the run `Segment(root, Chartist)`\n * @module Chartist.SegmentedLine\n */\n\nexport default function Segment (globalRoot, Chartist){\n  console.log(\"trying to generate chart\");\n  // var window = globalRoot.window;\n  // var document = globalRoot.document;\n\n  /**\n   * Default options in line charts. Expand the code view to see a detailed list of options with comments.\n   *\n   * @memberof Chartist.SegmentedLine\n   */\n  var defaultOptions = {\n    // Options for X-Axis\n    axisX: {\n      // The offset of the labels to the chart area\n      offset: 30,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'end',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // Set the axis type to be used to project values on this axis. If not defined, Chartist.StepAxis will be used for the X-Axis, where the ticks option will be set to the labels in the data and the stretch option will be set to the global fullWidth option. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.\n      type: undefined\n    },\n    // Options for Y-Axis\n    axisY: {\n      // The offset of the labels to the chart area\n      offset: 40,\n      // Position where labels are placed. Can be set to `start` or `end` where `start` is equivalent to left or top on vertical axis and `end` is equivalent to right or bottom on horizontal axis.\n      position: 'start',\n      // Allows you to correct label positioning on this axis by positive or negative x and y offset.\n      labelOffset: {\n        x: 0,\n        y: 0\n      },\n      // If labels should be shown or not\n      showLabel: true,\n      // If the axis grid should be drawn or not\n      showGrid: true,\n      // Interpolation function that allows you to intercept the value from the axis label\n      labelInterpolationFnc: Chartist.noop,\n      // Set the axis type to be used to project values on this axis. If not defined, Chartist.AutoScaleAxis will be used for the Y-Axis, where the high and low options will be set to the global high and low options. This type can be changed to any axis constructor available (e.g. Chartist.FixedScaleAxis), where all axis options should be present here.\n      type: undefined,\n      // This value specifies the minimum height in pixel of the scale steps\n      scaleMinSpace: 20,\n      // Use only integer values (whole numbers) for the scale steps\n      onlyInteger: false\n    },\n    // Specify a fixed width for the chart as a string (i.e. '100px' or '50%')\n    width: undefined,\n    // Specify a fixed height for the chart as a string (i.e. '100px' or '50%')\n    height: undefined,\n    // If the line should be drawn or not\n    showLine: true,\n    // If dots should be drawn or not\n    showPoint: true,\n    // If the line chart should draw an area\n    showArea: false,\n    // The base for the area chart that will be used to close the area shape (is normally 0)\n    areaBase: 0,\n    // Specify if the lines should be smoothed. This value can be true or false where true will result in smoothing using the default smoothing interpolation function Chartist.Interpolation.cardinal and false results in Chartist.Interpolation.none. You can also choose other smoothing / interpolation functions available in the Chartist.Interpolation module, or write your own interpolation function. Check the examples for a brief description.\n    lineSmooth: true,\n    // If the line chart should add a background fill to the .ct-grids group.\n    showGridBackground: false,\n    // Overriding the natural low of the chart allows you to zoom in or limit the charts lowest displayed value\n    low: undefined,\n    // Overriding the natural high of the chart allows you to zoom in or limit the charts highest displayed value\n    high: undefined,\n    // Padding of the chart drawing area to the container element and labels as a number or padding object {top: 5, right: 5, bottom: 5, left: 5}\n    chartPadding: {\n      top: 15,\n      right: 15,\n      bottom: 5,\n      left: 10\n    },\n    // When set to true, the last grid line on the x-axis is not drawn and the chart elements will expand to the full available width of the chart. For the last label to be drawn correctly you might need to add chart padding or offset the last label with a draw event handler.\n    fullWidth: false,\n    // If true the whole data is reversed including labels, the series order as well as the whole series data arrays.\n    reverseData: false,\n    // Override the class names that get used to generate the SVG structure of the chart\n    classNames: {\n      chart: 'ct-chart-line',\n      label: 'ct-label',\n      labelGroup: 'ct-labels',\n      series: 'ct-series',\n      line: 'ct-line',\n      point: 'ct-point',\n      area: 'ct-area',\n      grid: 'ct-grid',\n      gridGroup: 'ct-grids',\n      gridBackground: 'ct-grid-background',\n      vertical: 'ct-vertical',\n      horizontal: 'ct-horizontal',\n      start: 'ct-start',\n      end: 'ct-end'\n    },\n    segmentClassPrefix: 'ct-segment-',\n    metaRangeProperty: 'quality',\n    metaRangeValue: [[0,10,'bad'], [10,30,'shoulder'], [30,150,'good'],[150,180,'shoulder'],[180,360,'bad']]\n   };\n\n\n  /**\n   * Divide the series into su-units on the bassis of a metadata property\n   * @param {} series\n   */\n  function collectSegments (series, metaField=defaultOptions.metaRangeProperty, dataRanges=defaultOptions.metaRangeValue) {\n    //console.log(series);\n    //console.log(metaField);\n    let segments = [],\n        segName = series[0] && series[0].meta[metaField],\n        current = [];\n    series.forEach( point => {\n      // console.log(point.meta);\n      // console.log(point.meta[metaField], point.meta.units);\n      current.push(point);\n      if (point.meta[metaField] === segName) {\n      } else {\n        segments.push({name: segName, points: current, data: current});\n        current = [point];\n        segName = point.meta[metaField];\n      }\n\n    });\n    segments.push({name: segName, points: current, data:current});\n    //console.log(segments);\n    return segments;\n  }\n\n  function drawSegment (segment, index, parent, options=defaultOptions) {\n    const {seriesElement, rect, axisX, axisY, data, seriesIndex} = parent,\n          segmentElement = seriesElement.elem('g');\n\n    // switch to destructuring defn!\n    // Write attributes to series group element. If series name or meta is undefined the attributes will not be written\n    segmentElement.attr({\n      'ct:segment-name': segment.name + index\n      //'ct:meta': Chartist.serialize(series.meta) // no meta data for this yet\n    });\n\n    // Use series class from series data or if not set generate one\n    segmentElement.addClass([\n      options.segmentClassPrefix + segment.name,\n      (segment.className || options.segmentClassPrefix + Chartist.alphaNumerate(index)) // TODO: implement className\n    ].join(' '));\n\n    //parent path/coords\n    let pathCoordinates = [],\n        pathData = [];\n      segment.points.forEach(function(value, valueIndex) {\n        let p = {\n          //x: parent.rect.x1 + axisX.projectValue(value, valueIndex, data.normalized.series[seriesIndex]),\n          x: parent.rect.x1 + axisX.projectValue(value, valueIndex, data.normalized.series[seriesIndex]),\n          y: parent.rect.y1 - axisY.projectValue(value, valueIndex, data.normalized.series[seriesIndex])\n        };\n        pathCoordinates.push(p.x, p.y);\n        pathData.push({\n          value: value,\n          valueIndex: valueIndex,\n          meta: Chartist.getMetaData(segment, valueIndex) //  value.meta// Chartist.getMetaData(series, valueIndex)\n        });\n      });\n    console.log(pathCoordinates, pathData);\n\n  }\n\n  /**\n   * Creates a new chart\n   *\n   */\n  function createChart(options) {\n    //console.log(\"datadatadata\")\n    //console.log(this.data);\n    // inherit this section from Line graph type\n    var data = Chartist.normalizeData(this.data, options.reverseData, true);\n\n    // Create new svg object\n    this.svg = Chartist.createSvg(this.container, options.width, options.height, options.classNames.chart);\n    // Create groups for labels, grid and series\n    var gridGroup = this.svg.elem('g').addClass(options.classNames.gridGroup);\n    var seriesGroup = this.svg.elem('g');\n    var labelGroup = this.svg.elem('g').addClass(options.classNames.labelGroup);\n\n    var chartRect = Chartist.createChartRect(this.svg, options, defaultOptions.padding);\n    var axisX, axisY;\n\n    if(options.axisX.type === undefined) {\n      axisX = new Chartist.StepAxis(Chartist.Axis.units.x, data.normalized.series, chartRect, Chartist.extend({}, options.axisX, {\n        ticks: data.normalized.labels,\n        stretch: options.fullWidth\n      }));\n    } else {\n      axisX = options.axisX.type.call(Chartist, Chartist.Axis.units.x, data.normalized.series, chartRect, options.axisX);\n    }\n\n    if(options.axisY.type === undefined) {\n      axisY = new Chartist.AutoScaleAxis(Chartist.Axis.units.y, data.normalized.series, chartRect, Chartist.extend({}, options.axisY, {\n        high: Chartist.isNumeric(options.high) ? options.high : options.axisY.high,\n        low: Chartist.isNumeric(options.low) ? options.low : options.axisY.low\n      }));\n    } else {\n      axisY = options.axisY.type.call(Chartist, Chartist.Axis.units.y, data.normalized.series, chartRect, options.axisY);\n    }\n\n    axisX.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n    axisY.createGridAndLabels(gridGroup, labelGroup, this.supportsForeignObject, options, this.eventEmitter);\n\n    if (options.showGridBackground) {\n      Chartist.createGridBackground(gridGroup, chartRect, options.classNames.gridBackground, this.eventEmitter);\n    }\n\n    // Draw the series\n    data.raw.series.forEach(function(series, seriesIndex) {\n      var seriesElement = seriesGroup.elem('g');\n      // Write attributes to series group element. If series name or meta is undefined the attributes will not be written\n      seriesElement.attr({\n        'ct:series-name': series.name,\n        'ct:meta': Chartist.serialize(series.meta)\n      });\n\n      // Use series class from series data or if not set generate one\n      seriesElement.addClass([\n        options.classNames.series,\n        (series.className || options.classNames.series + '-' + Chartist.alphaNumerate(seriesIndex))\n      ].join(' '));\n\n      //parent path/coords\n      // ignore?\n      var pathCoordinates = [],\n          pathData = [];\n\n      // ===============================\n      //\n      //   from here on we deal with SEGMENTS except when we need reference to series-specific\n      //   meta data\n      //\n      // ================================\n      const segments = collectSegments(series.data), // TODO: normalize data\n            segParent = {seriesElement, rect:chartRect, axisX, axisY, data, seriesIndex};\n      //segments.forEach( (seg, index) => drawSegment (seg, index, segParent));\n      //data.normalized.series[seriesIndex].forEach(function(value, valueIndex) {\n      console.log(segments);\n      let testCase;\n      // use arrow function to avoid binding `this`; segments aren't proper chartist objs\n      segments.forEach( function makeSegElements (segment, segmentIndex)  {\n        //console.log(\"seg name is defined?\");\n        //console.log(segment.name)\n        const segmentElement = seriesElement.elem('g');\n        segmentElement.attr({\n          'ct:segment-name': segment.name +'-' + segmentIndex,\n          'ct:series-name': series.name\n          //'ct:meta': Chartist.serialize(series.meta) // no meta data for this yet\n        });\n        segment.points[0] === testCase ? console.log(`oh no! first element of segment ${segmentIndex} = the one before`) : testCase = segment.points[0];\n        console.log(testCase);\n        // Use series class from series data or if not set generate one\n        segmentElement.addClass([\n          options.segmentClassPrefix + segment.name,\n          (segment.className || options.segmentClassPrefix + Chartist.alphaNumerate(segmentIndex)) // TODO: implement className\n        ].join(' '));\n\n\n        // bind(this!) be careful!\n        let segmentPathCoordinates = [],\n            segmentPathData = [];\n        segment.points.forEach(function(value, valueIndex) {\n\n        var p = {\n          x: chartRect.x1 + axisX.projectValue(value, valueIndex, data.normalized.series[seriesIndex]),\n          y: chartRect.y1 - axisY.projectValue(value, valueIndex, data.normalized.series[seriesIndex])\n        };\n        segmentPathCoordinates.push(p.x, p.y);\n        segmentPathData.push({\n          value: value,\n          valueIndex: valueIndex,\n          meta: Chartist.getMetaData(segment, valueIndex)\n        });\n      }.bind(this));\n\n        // some of these need to be reset!!\n      var seriesOptions = {\n        lineSmooth: Chartist.getSeriesOption(series, options, 'lineSmooth'),\n        showPoint: Chartist.getSeriesOption(series, options, 'showPoint'),\n        showLine: Chartist.getSeriesOption(series, options, 'showLine'),\n        showArea: Chartist.getSeriesOption(series, options, 'showArea'),\n        areaBase: Chartist.getSeriesOption(series, options, 'areaBase')\n      };\n\n      var smoothing = typeof seriesOptions.lineSmooth === 'function' ?\n        seriesOptions.lineSmooth : (seriesOptions.lineSmooth ? Chartist.Interpolation.monotoneCubic() : Chartist.Interpolation.none());\n      // Interpolating path where pathData will be used to annotate each path element so we can trace back the original\n      // index, value and meta data\n      var segmentPath = smoothing(segmentPathCoordinates, segmentPathData);\n        console.log(`SEGMENT PATH ELEMTNST HAS LENGTH ${segmentPath.pathElements.length}`)\n      // If we should show points we need to create them now to avoid secondary loop\n      // Points are drawn from the pathElements returned by the interpolation function\n      // Small offset for Firefox to render squares correctly\n      if (seriesOptions.showPoint) {\n\n        segmentPath.pathElements.forEach(function(pathElement, index) {\n          var point = segmentElement.elem('line', {\n            x1: pathElement.x,\n            y1: pathElement.y,\n            x2: pathElement.x + 0.01,\n            y2: pathElement.y\n          }, options.classNames.point).attr({\n            'ct:value': [pathElement.data.value.x, pathElement.data.value.y].filter(Chartist.isNumeric).join(','),\n            'ct:meta': Chartist.serialize(pathElement.data.meta)\n          });\n          if (index == 2) {(console.log(\"2!!!!\", pathElement.data.meta.direction))}\n          this.eventEmitter.emit('draw', {\n            type: 'point',\n            value: pathElement.data.value,\n            index: pathElement.data.valueIndex,\n            meta: pathElement.data.meta,\n            series: series,\n            seriesIndex: seriesIndex,\n            axisX: axisX,\n            axisY: axisY,\n            group: segmentElement,\n            element: point,\n            x: pathElement.x,\n            y: pathElement.y\n          });\n        }.bind(this));\n      }\n\n      if(seriesOptions.showLine) {\n        var line = segmentElement.elem('path', {\n          d: segmentPath.stringify()\n        }, options.classNames.line, true);\n\n        this.eventEmitter.emit('draw', {\n          type: 'line',\n          values: data.normalized.series[seriesIndex],\n          path: segmentPath.clone(),\n          chartRect: chartRect,\n          index: seriesIndex,\n          series: series,\n          seriesIndex: seriesIndex,\n          seriesMeta: series.meta,\n          axisX: axisX,\n          axisY: axisY,\n          group: segmentElement,\n          element: line\n        });\n      }\n\n      // Area currently only works with axes that support a range!\n      if(seriesOptions.showArea && axisY.range) {\n        // If areaBase is outside the chart area (< min or > max) we need to set it respectively so that\n        // the area is not drawn outside the chart area.\n        var areaBase = Math.max(Math.min(seriesOptions.areaBase, axisY.range.max), axisY.range.min);\n\n        // We project the areaBase value into screen coordinates\n        var areaBaseProjected = chartRect.y1 - axisY.projectValue(areaBase);\n\n        // In order to form the area we'll first split the path by move commands so we can chunk it up into segments\n        segmentPath.splitByCommand('M').filter(function onlySolidSegments(pathSegment) {\n          // We filter only \"solid\" segments that contain more than one point. Otherwise there's no need for an area\n          return pathSegment.pathElements.length > 1;\n        }).map(function convertToArea(solidPathSegments) {\n          // Receiving the filtered solid path segments we can now convert those segments into fill areas\n          var firstElement = solidPathSegments.pathElements[0];\n          var lastElement = solidPathSegments.pathElements[solidPathSegments.pathElements.length - 1];\n\n          // Cloning the solid path segment with closing option and removing the first move command from the clone\n          // We then insert a new move that should start at the area base and draw a straight line up or down\n          // at the end of the path we add an additional straight line to the projected area base value\n          // As the closing option is set our path will be automatically closed\n          return solidPathSegments.clone(true)\n            .position(0)\n            .remove(1)\n            .move(firstElement.x, areaBaseProjected)\n            .line(firstElement.x, firstElement.y)\n            .position(solidPathSegments.pathElements.length + 1)\n            .line(lastElement.x, areaBaseProjected);\n\n        }).forEach(function createArea(areaPath) {\n          // For each of our newly created area paths, we'll now create path elements by stringifying our path objects\n          // and adding the created DOM elements to the correct series group\n          var area = segmentElement.elem('path', {\n            d: areaPath.stringify()\n          }, options.classNames.area, true);\n\n          // Emit an event for each area that was drawn\n          this.eventEmitter.emit('draw', {\n            type: 'area',\n            values: data.normalized.series[seriesIndex],\n            path: areaPath.clone(),\n            series: series,\n            seriesIndex: seriesIndex,\n            axisX: axisX,\n            axisY: axisY,\n            chartRect: chartRect,\n            index: seriesIndex,\n            group: segmentElement,\n            element: area\n          });\n        }.bind(this));\n      }\n      }.bind(this));\n\n    }.bind(this));\n\n    this.eventEmitter.emit('created', {\n      bounds: axisY.bounds,\n      chartRect: chartRect,\n      axisX: axisX,\n      axisY: axisY,\n      svg: this.svg,\n      options: options\n    });\n  }\n\n  /**\n   * This method creates a new segmented line chart.\n   *\n   * @memberof Chartist.SegmentedLine\n   * @param {String|Node} query A selector query string or directly a DOM element\n   * @param {Object} data The data object that needs to consist of a labels and a series array\n   * @param {Object} [options] The options object with options that override the default options. Check the examples for a detailed list.\n   * @param {Array} [responsiveOptions] Specify an array of responsive option arrays which are a media query and options object pair => [[mediaQueryString, optionsObject],[more...]]\n   * @return {Object} An object which exposes the API for the created chart\n   *\n   * @example\n   * // Create a simple line chart\n   * var data = {\n   *   // A labels array that can contain any sort of values\n   *   labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'],\n   *   // Our series array that contains series objects or in this case series data arrays\n   *   series: [\n   *     [5, 2, 4, 2, 0]\n   *   ]\n   * };\n   *\n   * // As options we currently only set a static size of 300x200 px\n   * var options = {\n   *   width: '300px',\n   *   height: '200px'\n   * };\n   *\n   * // In the global name space Chartist we call the SegmentedLine function to initialize a line chart. As a first parameter we pass in a selector where we would like to get our chart created. Second parameter is the actual data object and as a third parameter we pass in our options\n   * new Chartist.SegmentedLine('.ct-chart', data, options);\n   *\n   * @example\n   * // Use specific interpolation function with configuration from the Chartist.Interpolation module\n   *\n   * var chart = new Chartist.SegmentedLine('.ct-chart', {\n   *   labels: [1, 2, 3, 4, 5],\n   *   series: [\n   *     [1, 1, 8, 1, 7]\n   *   ]\n   * }, {\n   *   lineSmooth: Chartist.Interpolation.cardinal({\n   *     tension: 0.2\n   *   })\n   * });\n   *\n   * @example\n   * // Create a line chart with responsive options\n   *\n   * var data = {\n   *   // A labels array that can contain any sort of values\n   *   labels: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'],\n   *   // Our series array that contains series objects or in this case series data arrays\n   *   series: [\n   *     [5, 2, 4, 2, 0]\n   *   ]\n   * };\n   *\n   * // In addition to the regular options we specify responsive option overrides that will override the default configutation based on the matching media queries.\n   * var responsiveOptions = [\n   *   ['screen and (min-width: 641px) and (max-width: 1024px)', {\n   *     showPoint: false,\n   *     axisX: {\n   *       labelInterpolationFnc: function(value) {\n   *         // Will return Mon, Tue, Wed etc. on medium screens\n   *         return value.slice(0, 3);\n   *       }\n   *     }\n   *   }],\n   *   ['screen and (max-width: 640px)', {\n   *     showLine: false,\n   *     axisX: {\n   *       labelInterpolationFnc: function(value) {\n   *         // Will return M, T, W etc. on small screens\n   *         return value[0];\n   *       }\n   *     }\n   *   }]\n   * ];\n   *\n   * new Chartist.SegmentedLine('.ct-chart', data, null, responsiveOptions);\n   *\n   */\n  function SegmentedLine(query, data, options, responsiveOptions) {\n    Chartist.SegmentedLine.super.constructor.call(this,\n      query,\n      data,\n      defaultOptions,\n      Chartist.extend({}, defaultOptions, options),\n      responsiveOptions);\n  }\n\n  // Creating line chart type in Chartist namespace\n  Chartist.SegmentedLine = Chartist.Base.extend({\n    constructor: SegmentedLine,\n    createChart: createChart\n  });\n\n}\n","import moment from '../node_modules/moment/moment.js'\n/* \n\n   RIVER GAUGE DEFINITIONS\n\n*/\n\n\n// const cors = `https://hackinghistory.ca:9090/`\n/* DICTIONARY mapping gauge type to function */\n\n// I think fn symbols are hoisted so should be ok here?\nconst gaugeDict = {\n  cvc: processWiskiData,\n  grca: processWiskiData,\n  wateroffice: processWOData\n}\n\n/* TESTER for all gauge types */\n\nfunction testGood (level, spotMeta) {\n  let value = 'bad';\n  spotMeta.levels\n    .some( function (d)  {\n      if ( (d[0] < level) && ( level < d[1])  ) {\n        // console.log(d);\n        return value = d[2] }\n      return value});\n  //console.log(value)\n  return value\n}\n\n\n/*\n *\n * WISKI/KIWIS-based gauges (currently grca & cvc)\n * see notes for individual discrapncies\n * all sources so far seem to support KiWIS 1.6.1 api as outlined here:\n * https://waterdata.grandriver.ca/KiWIS/KiWIS?datasource=0&service=kisters&type=queryServices&request=getrequestinfo\n */\n\n\n\nasync function processWiskiData (spot, last) {\n  // this might stop working if we get other similar data sources, may need to\n  // refactor!\n  // have now discovered kiwi endpoints for bot conserveration area, os\n  // no longer need  so many functions, just a  baseurl switch.\n\n  // note we are nto actually using STATION ids, but instead TIMESERIES ids\n  // this can be confusing & messes w/ the data model a bit. \n  const baseURL = spot.gaugeType === 'cvc' ? `https://waterinfo.cvc.ca/` : `https://waterdata.grandriver.ca/`,\n        baseParams = `KiWIS/KiWIS?service=kisters&type=queryServices&request=getTimeseriesValues&datasource=0&format=dajson`,\n        id = spot.gaugeID,\n        start = moment(last).subtract(4, 'days').format('YYYY-MM-DD'),\n        end = moment(last).format('YYYY-MM-DD'),\n        url = `${baseURL + baseParams}&ts_id=${id}&from=${start}&to=${end}&dateformat=UNIX`;\n  console.log('KIWIPROCESS', spot.gaugeType, spot, url)\n  return fetch(url)\n      .then ( async (res) => {\n        console.log(res.headers.get('Content-Type'))\n        return res.json()\n      })\n    .then ( (json) => {\n      console.log('PROCESSWISKIJSON', json);\n      return json[0].data\n        .map( (item) => {\n        let meta = {};\n        meta.height = Number(item[1]);\n        meta.quality = testGood(item[1], spot);\n        meta.units = spot.units;\n        meta.data = item;\n        // note: may need to adjust date for DST & time zone -- cf.\n        // functions & comments in https://apps.grandriver.ca/waterdata/kiwischarts/js/RF_Charts.js?v1.0\n        // lines ~43-65\n        const itemObj = {x: item[0],\n                         y: item[1],\n                         meta: meta\n                        }\n        return itemObj })    \n    })\n    .catch(function(error){console.log('PROCESSWISKIERR', error);})\n  // console.log (\"MAP\")\n\n}\n\n\n\n// let proxy = 'https://cors-anywhere.herokuapp.com/';\nasync function getWOJSON (stationData, last, needCors = true) {\n  console.log('RIVER', stationData)\n  let start = moment(last).subtract(4, 'days').format('YYYY-MM-DD'),\n      end = moment(last).format('YYYY-MM-DD'),\n      headers = {Origin: \"localhost\"},\n      params = `?param1=47&start_date=${start}&end_date=${end}&station=${stationData[\"gaugeID\"]}`,\n      cors = `https://hackinghistory.ca:9090/`, // `https://cors-anywhere.herokuapp.com/`\n      url = `https://wateroffice.ec.gc.ca/services/real_time_graph/json/inline${params}`;\n  if (needCors) {url = `${cors}${url}`;}\n  console.log(url);\n  // let target = `${url}${params}`;\n  return await fetch(url, {headers: headers})\n    .then ( async (res) => {\n      console.log(res.headers.get('Content-Type'))\n      return res.json()\n    })\n    .then ( (json) => { console.log(json);return json[\"47\"].provisional} )\n    .catch(function(error){console.log(error);});\n}\n\n\nasync function processWOData (spot, latest) {\n  return getWOJSON(spot, latest)\n    .then ( function (rawData)  {\n      return rawData.map((item) => {\n        let meta = {};\n        meta.height = Number(item[1]);\n        meta.quality = testGood(item[1], spot);\n        meta.units = spot.units;\n        const itemObj =  { x: new Date(item[0]),\n                           y: item[1],\n                           meta: meta\n                         };\n        // console.log(itemObj);\n        return itemObj\n      })\n    })\n    .catch( (err) => [])\n      \n}\n\nasync function processGauge (spot, date, mapper=gaugeDict) {\n  console.log('PROCCESSGAUGE', spot.gaugeType, mapper[spot.gaugeType]);\n  return await mapper[spot.gaugeType](spot, date);\n}\n\n\nclass DataParser {\n  constructor(gaugeMap=gaugeDict){\n    // this.type = type;\n    this.gaugeMap=gaugeMap;\n  }\n\n  async process(spot) {\n    const m=this.gaugeMap\n    console.log(spot.gaugeType, m[spot.gaugeType]);\n    return await m[spot.gaugeType](spot);\n\n  }\n}\n\nexport default DataParser\nexport {processGauge, getWOJSON}\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport Markdown from 'markdown-to-jsx'\n\nexport default class MarkdownFromUrl extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      content : '',\n    }\n  }\n  componentDidMount = () => {\n    const errText = '## No River Info Available'\n    fetch(this.props.url)\n      .then( (res) => res.text())\n      .then( (text) => (text.length > 0 && text.substring(0,15) !== '<!DOCTYPE html>') ?\n             this.setState({content: text}) && console.log(\"MARKDOWN\", text) :\n             this.setState({content:errText}) )\n      .catch (() => (err) => this.setState({content:errText + err}))\n  }\n  \n  render() {\n    return (\n      <Markdown>\n      {this.state.content}\n      </Markdown>)\n  }\n}\n","import React from 'react'\nimport MarkdownFromUrl from './markdownFromUrl.js'\nimport Waterchart from '../components/waterchart.js'\n\nexport class Point extends React.Component {\n  render() {\n    const l=this.props.location,\n          url=`https://www.google.com/maps/dir/?api=1&destination=${l[0]},${l[1]}`\n    return (\n      <li>\n        <a href={url}>{this.props.name}</a>\n      </li>\n    )\n  }\n}\n\nexport class PointList extends React.Component {\n  render() {\n    const pEntries = Object.entries(this.props.points)\n    return (\n      <div>\n      <h2 value=\"Map Links\">Map Links</h2>\n      <ul>\n      {pEntries.length > 0 ?\n       pEntries.map( (point, index) => {\n         return <Point key={index} name={point[0]} location={point[1]}/>\n       }) :\n       <li>No Point Locations Provided</li>\n      } \n      </ul>\n      </div>\n    )\n  }\n}\n\nexport default class RiverTabPanel extends React.Component {\n  render() {\n    const {points, slug} = this.props.river\n    return (\n      <div>\n        <Waterchart\n          spotslug={slug}\n          checkUpdates={true}\n        />\n        {points && <PointList points={points}/>}\n        <MarkdownFromUrl url={`./descriptions/${slug}.md`}/>\n        </div>\n    )\n  }\n}\n\n\n","import React, { Component } from 'react'\nimport { Tab, Tabs, TabList, TabPanel } from 'react-tabs';\nimport 'react-tabs/style/react-tabs.css'\nimport RiverTabPanel from './riverTabPanel.js'\nexport default class WaterTabs extends Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      tabList: [],\n      tabPanelArray: []\n    }\n  }\n\n  componentDidMount = () => {\n    console.log(\"WATERTABS\", this.props.rivers)\n    const contentMap = this.props.rivers.map( (r) => {\n      return <TabPanel key={r.slug}><RiverTabPanel river={r}/></TabPanel>})\n    const tabMap = this.props.rivers.map( (r, index) => {\n      return <Tab key={r.slug}>{r.name}</Tab>})\n    this.setState({tabList: tabMap, tabPanelArray: contentMap})\n    console.log(\"WATERTABS PANELS\", this.state.tabPanelArray)\n  }\n  \n  render() {\n    return (\n      <Tabs defaultIndex={1} defaultFocus={true}>\n        <TabList>\n          {this.state.tabList}\n        </TabList>\n        {this.state.tabPanelArray}\n      </Tabs>\n    )\n  }\n}\n","import '../../node_modules/chartist/dist/chartist.min.css'\nimport React from 'react';\n// import PropTypes from 'prop-types'\nimport '../index.css';\nimport Rivers from  '../rivers.js';\nimport Waterchart from '../components/waterchart.js'\n\n\nfunction getSpot (slug) {\n  let value;\n  console.log(\"GETSPOT\", slug)\n  for (const r of Rivers) {\n    console.log('GETSPOT', r.slug, slug);\n    if (r.slug === slug ) {value = r;}\n  }\n  return value;\n}\n\n\nexport default class SessionInfo extends React.Component {\n  constructor(props) {\n    super(props);\n    this.spotDef = getSpot(this.props.spot)\n  }\n\n  componentDidMount() {\n  }\n\n  \n  render() {\n    // TODO: Still al to of extra divs here, can we simplify? \n    return (\n      <div className={`${this.props.className} session-meta`}\n           ref={(el) => this.containerRef=el}>\n        <div className=\"session-data\">\n          <Waterchart height={400}\n                      spotslug={this.props.spot}  date={this.props.date}\n                      width={this.containerRef && this.containerRef.current ?\n                                    this.containerRef.current.clientWidth :\n                                    800}\ns          />\n          {/* <RechartWaterChart data={this.state.gaugeData}/> */}\n        </div>\n      </div>\n    )\n  }\n}\n// export default connect(mapStateToProps)(SessionInfo)\n","import React from 'react';\nimport { connect } from 'react-redux';\nimport uuid from 'uuid/v4'\nimport Rivers from  '../rivers.js';\n\n// 'state' is actually *redux store*,\n// which is I guess a 'state', but obvs *not*\n// plain old react state.  \nfunction mapStateToProps(state) {\n  return {\n    entries: state.journal.entries\n  };\n}\n\nexport class JournalForm extends React.Component {\n  constructor(props) {\n    super(props)\n    const {spot, date, entry, id} = this.props\n    this.state = {\n      spot: spot || \"grand\",\n      date: date,\n      entry: entry,\n      id : id || uuid()\n    }\n  }\n  handleSubmit = (entry) => {\n    console.log('FORMUPDATE', entry);\n    this.props.dispatch({type: (this.props.submit === \"update\") ?\n                         'UPDATE_ENTRY' : 'ADD_ENTRY',\n                         payload: entry})\n  }\n\n  handleChange = (event) => {\n    const target = event.target;\n    const value = target.type ==='checkbox' ? target.checked : target.value;\n    const name = target.name;\n    this.setState({[name]: value})    \n  }\n\n  onSubmit = (event) => {\n    const {spot, date,entry,id} = this.state;\n    const info = {\n      spot: spot,\n      date: date,\n      entry: entry,\n      id: id \n    };\n    event.preventDefault();\n    this.handleSubmit(info);\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.onSubmit}>\n        <label>\n          Spot:\n          <select name=\"spot\" value={this.state.spot} onChange={this.handleChange}>\n      {Rivers.map( (r, index) =>\n        <option key={index} value={r.slug}>{r.name}</option>\n            )}\n          </select>\n        </label>\n        <label >\n          date:\n          <input name=\"date\" type=\"text\" value={this.state.date} onChange={this.handleChange}/>\n        </label>\n      <label className=\"entry\">\n          What Happened?:\n          <textarea name=\"entry\" value={this.state.entry} onChange={this.handleChange}/>\n        </label>\n        <input type=\"submit\" value=\"Submit\"/>\n      </form>\n    );\n  }\n}\n\nexport default connect(mapStateToProps)(JournalForm)\n","import '../../node_modules/chartist/dist/chartist.min.css'\nimport React from 'react';\nimport '../index.css';\nimport { connect } from 'react-redux';\nimport SessionInfo from '../components/sessionInfo.js'\nimport JournalForm from './journalForm.js'\n\n// 'state' is actually *redux store*,\n// which is I guess a 'state', but obvs *not*\n// plain old react state.  \nfunction mapStateToProps(state) {\n  return {\n    entries: state.journal.entries\n  };\n}\n\nexport class Journal extends React.Component {\n\n   render() {\n    console.log(\"rendering main journal\")\n    console.log(this.props.entries)\n    return (\n      <div className=\"journal\">\n        <JournalForm submit=\"add\"/>\n        {this.props.entries && <JournalAllEntries entries={this.props.entries}/>}\n      </div>\n    )\n  }\n}\n\n\nclass JournalAllEntries extends React.Component {\n  \n  render() {\n    console.log(\"rerendering entries\")\n    console.log('ALLENTRIES', this.props.entries)\n    return (\n      <div className=\"journal-entries\">\n        {/* <JournalRow spot=\"MEMEM\" date=\"DATEDATE\" entry=\"whatevs\"/> */}\n        {this.props.entries.map( (dataObj, index) =>\n          <JournalRow key={dataObj.id} id={dataObj.id} spot={dataObj.spot}\n                      date={dataObj.date} entry={dataObj.entry}\n                      showForm={false}/> )}\n        {this.props.entries.forEach( (entry, index) => console.log(entry, index))}\n      </div>\n    )\n  }\n}\n\n\nclass JournalRow extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      infoShown:  false,\n      showForm: this.props.showForm\n    }\n  }\n  \n  showInfo = () => {\n    this.setState({infoShown: !this.state.infoShown})\n  }\n\n  toggleForm = () => {\n    this.setState({showForm: !this.state.showForm})\n  }\n  render() {\n    return (\n      <div className=\"journal-row\">\n      <div className =\"entry\">\n        <div className=\"buttons\">\n          <button className =\"spot-info\"\n                  onClick={this.showInfo}>\n            {this.state.infoShown ?\n             `Hide Graphs` : `Show Graphs`}\n          </button>\n          <button className =\"update\"\n                  onClick={this.toggleForm}>\n      {this.state.showForm ?\n       `Hide Update Form` : `Update Entry` }\n          </button>          \n        </div>\n        <div className=\"journal-field\">{this.props.spot}</div>\n        <div className=\"journal-field\">{this.props.date}</div>\n        <div className=\"journal-field\">{this.props.entry}</div>\n      </div>\n        {this.state.showForm && <JournalForm id={this.props.id}\n                                             spot={this.props.spot}\n                                             entry={this.props.entry}\n                                             date={this.props.date}\n                                             submit=\"update\"/>}\n      <SessionInfo forceHidden={!this.state.infoShown} className={this.state.infoShown ? \"active\" : \"hidden\"} spot={this.props.spot} date={this.props.date}/>\n      </div>\n    )\n  }\n}\n\n\n\n\nexport default connect(mapStateToProps)(Journal)\n","import '../node_modules/chartist/dist/chartist.min.css'\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport './rivers.css';\nimport Rivers from  './rivers.js';\nimport * as serviceWorker from './serviceWorker';\nimport WaterTabs from './components/watertabs.js'\n// import {Point, PointList, MarkdownFromUrl, RiverTabPanel} from './components/watertabs.js'\nimport MarkdownFromUrl from './components/markdownFromUrl.js'\nimport Journal from './components/journal.js'\nimport 'react-tabs/style/react-tabs.css';\nimport {\n  Router,\n  Link\n} from \"@reach/router\";\nimport { Provider } from 'react-redux';\nimport { createStore } from 'redux';\nimport { persistStore, persistReducer } from 'redux-persist'\n// TODO: switch from localStorage to indexedDB\nimport { PersistGate } from 'redux-persist/integration/react'\nimport storage from 'redux-persist/lib/storage' // defaults to localStorage for web\n\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n}\n\nconst initialState = {\n  journal: {\n    entries: [\n      {spot: 'irvine', date: 'December 10, 2019', id: 235,\n       entry:'Moderate Level.  somewhat sticky hole at the bottom of three ledges, Mike flipped and the hole was big enough to hold a solo canoe.  Flippy hole at the river-right bottom of Triple Drop, flipped both me and Ian. River left, center both too low torun; pothole in trible drop river right clearly visible as a spouting rooster tail. Ledges clearly visible within the dam waterfall, deifnitely below a safe level for me to run.  Canyon section no harder than class II,but still continuous to the junction with the Gorge section.  Gorge fairly mellow, Chute at a good level.'}],\n    current: {spot:'', date:'', entry:'' }\n  },\n  charts: {},\n  sessions: {},\n  current: {}\n}\n\n\nfunction mainReducer(state=initialState, action) {\n  // just gonna leave this blank for now\n  // which is the same as `return undefined;`\n  switch (action.type) {\n  case 'ADD_ENTRY':\n    // TODO: should these be object properties instead?\n    // might make it easier to update\n    return {...state, \n            journal : {entries: [action.payload,\n                                 ...state.journal.entries]}\n           }\n  case 'UPDATE_ENTRY':\n    // TODO: fix so that we iterate through and change the one entry\n    // should be really easy but feels a bit unwieldy\n    return {...state, \n            journal : {\n              entries: state.journal.entries.map( (entry) => {\n                if (entry.id === action.payload.id) {\n                  return action.payload\n                }\n                return entry \n              })\n            }\n           }\n  case 'UPDATE_CHART':{\n    const newState = {...state}\n    newState.charts[action.id] = action.payload\n    return newState\n  }\n  case 'UPDATE_SESSION':{\n    const newState = {...state}\n    newState.sessions[action.id] = action.payload\n    return newState\n  }\n  case 'UPDATE_CURRENT': {\n    const newState = {...state}\n    newState.current[action.id] = action.payload\n    \n  }\n    //TODO: add break statements to fix 'no fallthrough'\n  default:\n    return state\n    \n  }\n}\n\n\n\nconst persistedReducer = persistReducer(persistConfig, mainReducer)\n\nconst store = createStore(persistedReducer,\n                          window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());\nconst persistor = persistStore(store)\n// const Chartist = require('chartist')\n\nfunction App(props) {\n  return (\n    <Provider store={store}>\n    <PersistGate loading={null} persistor={persistor}>\n        <nav className=\"nav bg-light\">\n          <Link className=\"brand\" to=\"/\">S.O. Shreds</Link>\n          <Link to=\"/rivers\">Rivers: Current Levels</Link>\n          <Link to=\"/journal\">Journal</Link>\n          <Link to=\"/about\">About</Link>\n        </nav>\n\n        <Router>\n          <WaterTabs path=\"rivers\" rivers={Rivers}/>\n          <Journal path=\"journal\" rivers={Rivers}/>\n          <MarkdownFromUrl path=\"about\" url=\"descriptions/about.md\"/>\n    </Router>\n    </PersistGate>\n    </Provider>\n  )\n}\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root'))\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}